---
title: 正则第二章-正则表达式位置匹配攻略
date: 2019-09-16 11:52:53
categories:
    - JavaScript
    - 正则表达式
tags:
---


# 前言
本篇大幅参考[掘金老姚](https://juejin.im/post/5965943ff265da6c30653879)  

# 正则表达式位置匹配攻略
正则表达式是匹配模式，要么匹配字符，要么匹配位置，本篇是位置匹配攻略。
<!-- more -->

# 目录
- [什么是位置](#什么是位置)
- [如何匹配位置](#如何匹配位置)
  - [^和$](#^和$)
  - [\b和\B](#\b和\B)
  - [(?=p)和(?!p)](#(?=p)和(?!p))
- [位置的理解](#位置的理解)
- [案例分析](#案例分析)
  - [不匹配任何字符的正则](#不匹配任何字符的正则)
  - [数字的千分位表示法](#数字的千分位表示法)
  - [验证密码问题](#验证密码问题)
    - [解法一](#解法一)
    - [解法二](#解法二)
- [总结](#总结)


# 什么是位置
位置是相邻字符之间的位置。如下图的箭头指向的地方：    
![位置](http://source.strugglexiang.xyz/1568172120.jpg)

# 如何匹配位置
正则表达式中有如下字符（锚字符）表示位置：  
> ^  多行匹配中匹配开头
>
> $  多行匹配中匹配结尾
>
> \b 单词边界
>
> \B 非单词边界
>
> (?=p) 正向先行断言
>
> (?!p) 负向先行断言

下面分别详细解释上述位置所代表的含义。

## ^和$
^(脱字符)：多行匹配中匹配开头  
$(美元符号)：多行匹配中匹配结尾

例1：
```js
console.log('hello'.replace(/^|$/g, '#'))
// => #hello#
```
没错，位置的可以替换的，上述示例中开头和结尾都替换成了`#`。

注意：   
1. 上述示例中使用到`g`修饰符，表示全局匹配，如不使用将只会匹配开头`^`。
2. 如果需要替换位置，正则表达式中应只出现表示位置锚字符，如果锚字符和普通字符同时使用，匹配（或替换）的将是普通字符。如：
```js
var regex  = /o\b/
console.log('dnoddfadfno ddd'.replace(regex, '#'))
// => 'dnoddfadfn# ddd'
```
可以看到，第二个`0`被替换成了`#`。也就是说，位置符的主要作用是**对要匹配的字符做某种条件限制**（这一点在自己写正则时比较关键）。


例2： 
```js
var str = 'I\nlove\njavaScript'
console.log(str.replace(/^|$/gm, '#'))
// => #I#\n#love#\n#javascript#
```
上述示例使用`m`修饰符，表示多行匹配


## \b和\B
\b：单词边界。具体就是`\w和\W`、`\w和^`、`\w和$`之间的位置。

例：
```js
var str = '[xian]yu.jpg'
str = str.replace(/\b/g, '#')
console.log(str)
// => [#xian#]#yu#.#jpg# 
```
解析：  
我们知道\w的[0-9a-zA-Z_]的简写，\W是[^0-9a-zA-Z_]的简写  
1. 第1个# \W与\w 即`[`与`x`之间的位置
2. 第2个# \w与\W 即`n`与`]`之间的位置
3. 第3个# \W与\w 即`]`与`y`之间的位置
4. 第4个# \w与\W 即`u`与`.`之间的位置
5. 第5个# \W与\w 即`.`与`j`之间的位置
6. 第6个# \w与\W 即`g`与`$`之间的位置

\B：非单词边界。它是`\b`的反义，即去掉字符串的所有的`\b`，其余位置都是`\B`。具体表示`\w和\w`、`\W和\W`、`\W和^`、`\W和$`之间的位置。
例：
```js
var str = '[xian]yu.jpg'
str = str.replace(/\B/g, '#')
console.log(str)
// => #[x#i#a#n]y#u.j#p#g 
```
> 快速记忆：单词之间的所有位置都是\B
> 
> xian => x#i#a#n

## (?=p)和(?!p)
(?=p)：其中p表示一个子模式，即**p前面的位置**。它的英文是`positive lookahead`，翻译成正向先行断言。
```js
var regex = /(?=l)/g
var str = 'hello'
console.log(str.replace(regex, '#'))
// => he#l#lo
```
可以看到，`l`前的位置被替换成了`#`


(?!p)：negative lookahead，负向先行断言，它是`(?=p)`的反义，即某个不是p的字符前面的位置。
```js
var regex = /(?!l)/g
var str = 'hello'
console.log(str.replace(regex, '#'))
// =>  #h#ell#o#
```

前面说过，位置除了可以替换外，它主要的作用是对某个要匹配的子模式做条件限制。  
例：
```js
var regex = /y(?=x)/
var str = 'y1yx'
console.log(str.replace(regex, '#'))
// y1#x
```
`/y(?=x)/`的在一些文献中一般都理解为**匹配y当且紧当y后面紧跟x时**。但是我们要将其做位置理解比较好，即：匹配y和x前面的位置。

除开正向先行断言和负向先行断言，es6中还支持正向后行断言和负向后行断言。 
> (?<=p) 正向后行断言(positive lookbehind)，匹配某个位置，该位置前面是p。
>
> (?<!p) 负向后行断言(negative lookbehind)，匹配某个位置，该位置前面不是p。


有关断言说了这么多，我自己本人都有点被饶糊涂了，以下是我个人的件记忆方式：
> (?=p) 匹配某个位置，该位置后面是p，对该位置后面做条件限制。 没有`<`，是先行断言，没有`!`，正向，正向先行断言。
>
> (?!p) 匹配某个位置，该位置后面不是p，对该位置后面做条件限制。没有`<`，是先行断言，有`!`，负向，负向先行断言。
> 
> (?<=p) 匹配某个位置，该位置前面是p，对该位置前面做条件限制。有`<`，是后行断言，没有`!`，正向，正向后行断言。
>
> (?<!p) 匹配某个位置，该位置前面不是p，对该位置前面做条件限制。有`<`，是后行断言，有`!`，负向，负向后行断言。


# 位置的理解
关于位置的理解，我们可以将其理解成空字符""。

例1：   
"hello" = "" + "h" + "" + "e" + "" + "l" + "" + "l" + "" + "0" + ""

例2：    
"hello" = "" + "" + "hello"

因此，位置是可以重叠的，`/^hello$/`也可以写成`/^^^hello$$$$/`
```js
console.log(/^hello$/.test('hello')) //true
console.log(/^^^hello$$$$/.test('hello'))//true
```

甚至可以写得更加复杂：
```js
console.log(/(?=he)^he(?=\w)llo\b\b$/.test('hello'))//true

console.log(/(?=he)^he(?=\w)ll\$$\B/.test('hell$'))//true
```
`hello`后的结尾是单词边界，`hell$`结尾是非单词边界，位置重叠使用时注意区分作用。

# 案例分析
## 不匹配任何字符的正则 
.^：匹配一个字符，该字符是后面是开头。

(?=x)y：某个位置后面紧跟x，却紧跟y，自相矛盾。

## 数字的千分位表示法
把`"12345678"`变成`12,345,678`

### 弄出最后一个逗号
```js
var regex = /(?=\d{3}$)/
console.log('12345678'.replace(regex, ','))
//12345,678
```
`$`符号不能写在括号外，即：/(?=\d{3})$/，位置重叠，这样匹配一个位置，该位置是结尾位置，并且该位置后紧跟3个数字，明显自相矛盾。

### 弄出多个逗号
从结束位置，每3个数字为一组，至少出现1次，因此使用量词`+`。
```js
var regex = /(?=(\d{3})+$)/g
console.log('12345678'.replace(regex, ','))
// 12,345,678
```
即从结尾开始，第n个连续3个数字前的位置替换成`,`

### 完善案例漏洞
```js
var regex = /(?=(\d{3})+$)/g
console.log('123456789'.replace(regex, ','))
// ,123,456,789
```
可以看到，需排除开头的位置，使用`(?!^)`
```js
var regex = /(?!^)(?=(\d{3})+$)/g
console.log('123456789'.replace(regex, ','))
// 123,456,789
```

### 支持其他形式
如果要将`"12345678 123456789"`替换成`"12,345,678 123,456,789"`，需要将^、$符号替换成`\b`
```js
var regex = /(?!\b)(?=(\d{3})+\b)/g
console.log('12345678 123456789'.replace(regex, ','))
// 12,345,678 123,456,789
```
即从单词边界开始，以3个数字为一组的位置添加`,`，但是这个位置不是能是单词边界。

其中，`(?!\b)`就是`\B`
```js
var regex = /\B(?=(\d{3})+\b)/g
console.log('12345678 123456789'.replace(regex, ','))
// => 12,345,678 123,456,789
```

## 验证密码问题
密码长度为6-12位，由数字、小写字母、大写字母组成，要求至少包含两种字符。

### 解法一
1、数字、小写字母、大写字母组成的6-12位密码，写成`/[0-9a-zA-z]{6-12}/`

2、要求必须包含某一种字符怎么写呢？前面我们说过，位置的一个很重要的作用是对要匹配的字符做条件限制。以必须包含数字为例，我们可以写成`/(?=.*[0-9])/`或者`(?=.*\d)`，意思是某个位置后面必含有一个数字。
```js
var regex = /(?=.*[0-9])^[0-9a-zA-z]{6-12}$/
```
可以看到，`/(?=.*[0-9])/`写在了开始位置符`^`的前面，两个位置重叠(即同一个位置，都是开头)，翻译成大白话就是，从开始位置开始，后面的字符必包含一个数字。

3、那么如何同时包含多个字符呢？举一反三，很容易写出来，以同时包含数字和小写字母为例，正则如下：
```js
var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9a-zA-z]{6-12}$/
```

4、分析一下，原题可以是以下几种情况之一：     
1. 同时包含数字和小写字母
2. 同时包含数字和大写字母
3. 同时包含小写祖母和大写字母
4. 同时包含数字、小写字母、大写字母。

以上4种情况是或的关系，第4钟情况可以省略，我们可以得到一个最终的正则：
```js
var regex = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9a-zA-Z]{6,12}$/
console.log( regex.test("1234567") ); //  全是数字 false
console.log( regex.test("abcdef") ); //  全是小写字母 false
console.log( regex.test("ABCDEFGH") ); //  全是大写字母 false
console.log( regex.test("ab23C") ); //  不足6位 false
console.log( regex.test("ABCDEF234") ); //  大写字母和数字 true
console.log( regex.test("abcdEF234") ); //  三者都有 true
```

### 解法二
上述密码问题还要第二种解法。`至少包含两种字符`的意思，可以理解为不能全是数字，也不能能全是大小写字母。可以使用`(?!p)`。  
1. 不能全是数字，`(?!^[0-9]{6,12}$)`
2. 不能全是小写字母，`(?!^[a-z]{6,12}$)`
3. 不能全是大写字母，`(?!^[A-Z]{6,12}$)`
```js
var regex = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9a-zA-z]{6,12}$/
console.log( regex.test("1234567") ); // false 全是数字
console.log( regex.test("abcdef") ); // false 全是小写字母
console.log( regex.test("ABCDEFGH") ); // false 全是大写字母
console.log( regex.test("ab23C") ); // false 不足6位
console.log( regex.test("ABCDEF234") ); // true 大写字母和数字
console.log( regex.test("abcdEF234") ); // true 三者都有
```

# 总结
1. 正则表达式的位置匹配，就是灵活使用6种锚字符，`^、$、\b、\B、(?=p)、(?!p)、`
2. 位置可以替换、重叠，要将其理解成为空字符`""`
3. 位置和普通字符组合使用时，主要作用是对普通字符做条件限制。


