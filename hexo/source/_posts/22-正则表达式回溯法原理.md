---
title: 正则第四章-正则表达式回溯法原理
date: 2019-09-23 11:50:14
categories:
    - JavaScript
    - 正则表达式
tags:
---

# 前言
本篇大幅参考[掘金老姚](https://juejin.im/post/5965943ff265da6c30653879)  


# 正则表达式回溯法原理
正则表达式的匹配原理中，`回溯`出现的频率比较高，跟着老姚的教程，本篇也来理解一下回溯法原理。
<!-- more -->

# 目录
- [没有回溯的匹配](#没有回溯的匹配)
- [有回溯的匹配](#有回溯的匹配)
  - [例1](#例1)
  - [例2](#例2)
  - [例3](#例3)
- [常见的回溯形式](#常见的回溯形式)
  - [贪婪量词](#贪婪量词)
  - [惰性量词](#分支结构)
  - [分支结构](#分支结构)
- [总结](#总结)

# 没有回溯的匹配
假设现在有正则表达式`/ab{1,3}c/`，它的可视形式如下：

![](http://source.strugglexiang.xyz/regexp_back_1.png)

当要匹配的字符串是`abbbc`时，这时候的匹配是没有回溯的。匹配过程是：

![](http://source.strugglexiang.xyz/regexp_back_2.png)

可以看到，正则表达式从左至右，各个部分(a、b{1,3}、c)依次匹配，没有出现某部分不匹配导致前面某部分重新匹配的情况。


# 有回溯的匹配
从正则的匹配过程来讲，回溯就是某部分不匹配导致前面部分去尝试其他的可能性，直到匹配完成或者匹配失败。

## 例1
同样以正则`/ab{1,3}c/`为例，去匹配字符串`'abbc'`，这个时候就会出现回溯。匹配过程如下：

![](http://source.strugglexiang.xyz/regexp_back_3.png)

图中第5步，红颜色表示匹配不成功。这个时候，正则的第3个b和c不匹配，表示`b{1,3}`这个取3个b的情况已经结束。然后正则尝试其他可能性，回到匹配2个b的情况下，再用c去匹配c，匹配就成功了。上述第6步就是我们所说的回溯，它回到了和第4步相同的情况。

## 例2
看完例1，可能感受不明显，我们再看一个更明显的示例。

正则：

![](http://source.strugglexiang.xyz/regexp_back_4.png)

目标字符串是`'abbbc'`，匹配过程如下：

![](http://source.strugglexiang.xyz/regexp_back_5.png)

第7步和第10步是回溯。第6步时，第4个b和c不匹配，也就是`b{1,3}取3个的情况匹配失败`，正则就会尝试`b{1,3}`取2个的情况下后续继续匹配。同理，到了第9步，匹配不成功，继续尝试`b{1,3}`取1个的情况，直到将匹配成功或者所有情况下都匹配失败(也代表正则匹配失败)。

## 例3
正则表达式`/".*"/`

![](http://source.strugglexiang.xyz/regexp_back_6.png)

目标字符串是"acd"ef，匹配过程：

![](http://source.strugglexiang.xyz/regexp_back_7.png)

`.*`可以匹配出现的任意字符，到了第8步，发现字符串已经匹配到尾了，此时正则还有最后一个`"`需要匹配，从而正则去尝试更多的可能（`.*`的匹配个数依次减少），直到`"`匹配成功或所有匹配失败。

为了减少回溯，正则可优化为`/"[^"]*"/`


# 常见的回溯形式
上述正则表达式这种匹配方式，叫做回溯法。

回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。


回溯法本质上是一种深度优先搜索算法，尽可能的探索正则的深度，匹配失败再退回。其中退到之前的某一步这一过程，我们称为“回溯”。可以看出，路走不通时，就会发生回溯。即**匹配失败时，通常下一步就是回溯**




既然知道了原理，那么正则表达式中会产生回溯的地方有哪些呢？

## 贪婪量词
之前所有的例子都是使用贪婪量词产生的，比如`b{1,3}`，因为它是贪婪的，尝试的顺序会是`从多到少`。首先会尝试`3个b`，匹配失败就回退到`2个b`，直到回退到某一步匹配成功或者所有情况都不匹配（也就是正则匹配失败）

虽然局部匹配是贪婪的，但也要满足整体。

当多个贪婪量词挨着存在，并相互有冲突时情况会是怎样？答案是先下手为强，因为深度优先搜索。
```js
var regex = /(\d{1,3})(\d{1,3})/
var string = '12345'
console.log(string.match(regex))
// ["12345", "123", "45", index: 0, input: "12345", groups: undefined]
```
可以看到，正则会先满足第一个`\d{1,3}`，回溯先以第二个`\d{1,3}`开始，因为第二个`\d{1,3}`深度更大。

## 惰性量词
惰性量词，就是在贪婪量词后加上`?`，它的原则是尽可能的少匹配。比如:
```js
var regex = /(\d{1,3}?)(\d{1,3})/
var string = '12345'
console.log(string.match(regex))
// ["1234", "1", "234", index: 0, input: "12345", groups: undefined]
```
因为是惰性的，第一个`\d{1,3}?`只匹配`1`。

虽然惰性量词的原则是少匹配，但是它也有产生回溯的地方。

正则如下：

![](http://source.strugglexiang.xyz/regexp_back_8.png)

目标字符串是`"12345"`，匹配过程

![](http://source.strugglexiang.xyz/regexp_back_9.png)

首先`\d{1,3}?`匹配到1个数字并且`\d{1,3}`匹配3个数字，然后发现`$`和`5`不匹配。虽然知道你不贪，但是为了满足整体，也只能给你多塞一个继续尝试，所以`\d{1,3}?`匹配的是`'12'`两个数字，而不是一个。

当多个惰性量词挨着存在，并存在冲突会怎么样？答案也是先下手为强，因为**深度优先搜索**（回溯会从匹配深度最近的地方开始）。  
```js
var reg = /^(\d{1,3}?)(\d{1,3}?)$/
console.log('123'.match(reg)) 
// => ["123", "1", "23", index: 0, input: "123", groups: undefined]
console.log('1234'.match(reg))
// => ["1234", "1", "234", index: 0, input: "1234", groups: undefined]
console.log('12345'.match(reg))
// => ["12345", "12", "345", index: 0, input: "12345", groups: undefined]
console.log('123456'.match(reg))
// => ["123456", "123", "456", index: 0, input: "123456", groups: undefined]
```
正则会先尽可能先满足`第一个\d{1,3}?`，回溯从`第二个\d{1,3}?`开始，因为`第二个\d{1,3}?`深度更大。



## 分支结构
我们知道，分支结构也是惰性，用`/good|goodbye/`去匹配字符串`"goodbye"`，得到的结果是`good`。因为分支结构会先尝试`good`，发现匹配成功，就不会继续往下尝试了。

但是有时候，分支结构形成局部匹配，整体不匹配，这个时候它就会尝试剩下的分支。这也可以看成一种回溯。
比如正则：

![](http://source.strugglexiang.xyz/regexp_back_10.png)

目标字符串是"candy"，匹配过程是：

![](http://source.strugglexiang.xyz/regexp_back_11.png)

第4步，虽然`can`局部匹配成功，但是整体匹配失败。为了满足整体，正则还是尝试了剩下的分支`candy`



# 总结
正则表达式回溯法很容易理解。

简单总结就是：正则表达式有多重可能性，所以要一个一个尝试。要么，到某一步时，整体匹配成功；要么，所有情况都尝试完，整体匹配失败，正则匹配失败。

回溯法的本质是深度优先搜索算法，尽可能的探索正则的深度，匹配失败再回溯，所以当多个同类型量词紧挨时，采取先下手为强的原则，从深度较大的部分开始回溯。

可能产生回溯的地方：
1. 贪婪量词。为了满足整体匹配，尝试方向从多到少。
2. 惰性量词。为了满足整体匹配，尝试方向从少到多。
3. 分支结构。为了满足整体匹配，尝试剩下分支。

显然易见，回溯是会消耗性能的，影响匹配效率。

