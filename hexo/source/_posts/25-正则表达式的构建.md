---
title: 正则第六章-正则表达式的构建
date: 2019-12-05 18:36:50
categories:
    - JavaScript
    - 正则表达式
tags:
---


# 前言
本篇大幅参考[掘金老姚](https://juejin.im/post/5965943ff265da6c30653879)  


# 正则表达式的构建
对一门语言的掌握程度，可以从两方面衡量：读和写。

既要看懂别人的解决方案，也需要自己能够独立解决问题。相对于“读”，“写”显然更重要一些。本篇介绍着重于“写”。

<!-- more -->


# 目录
- [平衡法则](#平衡法则)
- [使用正则的前提](#使用正则的前提)
  - [是否能够使用正则](#是否能够使用正则)
  - [是否有必要使用正则](#是否有必要使用正则)
  - [是否有必要构建一个复杂的正则](#是否有必要构建一个复杂的正则)
- [准确性](#准确性)
  - [匹配固定电话](#匹配固定电话)
  - [匹配浮点数](#匹配浮点数)
- [效率](#效率)
  - [使用具体字符组替代通配符](#使用具体字符组替代通配符)
  - [使用非捕型分组](#使用非捕型分组)
  - [独立出确定字符](#独立出确定字符)
  - [提取分支公共部分](#提取分支公共部分)
  - [减少分支数量](#减少分支数量)
- [总结](#总结)

# 平衡法则
构建正则有一点非常重要，需要做到以下几点的平衡：

1. 匹配预期的字符串
2. 不匹配非预期的字符串
3. 可读性和可维护性
4. 效率

# 使用正则的前提
## 是否能够使用正则
正则表达式如此强大，以致于我们在遇到字符串问题时都会下意识的想到用正则解决。但是我们要牢记一点，正则表达式虽然强大，但不是万能的，在使用正则之前，我们要确定正则能否解决问题。

比如需要匹配如下规则的字符串：`01001000100001...`，正则表达式是做不到的。

## 是否有必要使用正则
不要去研究正则无法做到的事情，同时也不要走另一个极端：无所不用正则。能够用api解决的简单问题，就不要强行使用正则。

比如提取日期中的年月日，虽然能够使用正则：
```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var str =  '2008-08-03'
console.log(str.match(regex))
// ["2008-08-03", "2008", "08", "03", index: 0, input: "2008-08-03", groups: undefined]
```
但是我们可以直接使用`String.split`：
```js
var str =  '2008-08-03'
console.log(str.split('-'))
// => ["2008", "08", "03"]
```

比如判断字符串中是否有问号，虽然能够使用正则：
```js
var regex = /\?/
var str = "?id=xx&act=search"
console.log(str.search(regex)) // => 0
```
但是我们可以直接使用`String.indexOf`：
```js
console.log("?id=xx&act=search".indexOf('?'))
// => 0
```

比如提取子串，虽然能够使用正则：
```js
var str = "JavaScript"
var regex = /.{4}(.+)/
console.log(str.match(regex)[1])
// => Script
```
但是我们可以直接使用`String.substring`
```js
console.log("JavaScript".substring(4))
// => Script
```

## 是否有必要构建一个复杂的正则
比如匹配密码问题，要求长度为6-12位，由数字、小写字母、大写字母组成，至少含有两种字符。

我们之前写过很长的正则：
```js
var regex = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9a-zA-Z]{6,12}$/
console.log(regex.test('123456')) // false
console.log(regex.test('abcdef')) // false
console.log(regex.test('ABCDEF')) // false
console.log(regex.test('ab123C')) // true
```
其实可以分为好几个正则来做：
```js
function valiPassword(str) {
    var regex1 = /^[0-9A-Za-z]{6,12}$/;
    var regex2 = /^[0-9]{6,12}$/
    var regex3 = /^[a-z]{6,12}$/
    var regex4 = /^[A-Z]{6,12}$/
    if(!regex1.test(str)) return false
    if(regex2.test(str)) return false
    if(regex3.test(str)) return false
    if(regex4.test(str)) return false
    return true
}
console.log(valiPassword('123456')) // false
console.log(valiPassword('abcdef')) // false
console.log(valiPassword('ABCDEF')) // false
console.log(valiPassword('ab123C')) // true
```
# 准确性
准确性，就是匹配预期字符，不匹配非预期字符。

为了提高准确性，就得知道目标字符的组成规则。

下面举例说明，当字符串构成比较复杂时，如何构建正则表达式，并考量到哪些平衡。

## 匹配固定电话
要匹配如下形式的固定电话：

> 055188888888
>
> 0551-88888888
>
> (0551)88888888

1. 了解各部分的构成规则，上面的电话形式，基本分成区号和号码两部分（不考虑分机号和+86的情形）。
2. 区号是0开头的3到4位数字，对应正则为：`0\d{2,3}`
3. 号码部分是非0开头的7到8位数字，对应正则为：`[1-9]\d{6,7}`
4. 匹配`055188888888`的正则为`/^0\d{2,3}[1-9]\d{6,7}$/`
5. 匹配`0551-88888888`的正则为`/^0\d{2,3}-[1-9]\d{6,7}$/` 
6. 匹配`(0551)88888888`的正则为`/^\(0\d{2,3}\)[1-9]\d{6,7}$/`
7. 这3者的形式是或的关系，使用管道符`|`将它们构建成分支，正则为`/^0\d{2,3}[1-9]\d{6,7}$|^0\d{2,3}-[1-9]\d{6,7}$|^\(0\d{2,3}\)[1-9]\d{6,7}$/`
8. 提取各个分支的公共部分，写成`/^(0\d{2,3}|0\d{2,3}-|\(0\d{2,3}\))[1-9]\d{6,7}$/`
9. 进一步简写，`/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/`

这样得到最终的正则`/^(0\d{2,3}-?|\(0\d{2,3}\))[1-9]\d{6,7}$/`，其可视化行形式：

![](http://source.strugglexiang.xyz/1569311728.jpg)

上述构建正则的步骤看起来很啰嗦，但是能保证正则是正确的。

不然就很容易的想当然的写成`/^\(?0\d{2,3}\)?-?[1-9]\d{6,7}$/`，虽然它也能匹配上述目标字符串，但是也匹配了`(0551-88888888`这样的字符串，这显然不符合要求。

其实，这个正则也是不完美的，因为并不是每个3-4个数字都是区号。这就是一个平衡取舍问题，一般够用就行。


## 匹配浮点数
要求匹配如下格式：

> 1.23、+1.23、-1.23
>
> 10、+10、-10
>
> .2、+.2、-.2

1. 分析上述格式的构成规则，主要分为符号部分、整数部分、小数部分这3个部分。
2. 符号部分，正则可写为：`[+-]`
3. 整数部分，正则可写为：`\d+`
4. 小数部分，正则可写为：`\.\d+`

这3个部分并不是要求都出现，很容易想当然地写成`/^[+-]?(\d+)?(\.\d+)?$/`， 虽然也能匹配上述形式，但也匹配了空字符串`""`。

对于`1.23、+1.23、-1.23`，可以使用`/^[+-]?\d+\.\d+$/`  
对于`10、+10、-10`，可以使用`/^[+-]?\d+$/`  
对于`.2、+.2、-.2`，可以使用`/^[+-]?\.\d+$/`  
他们之间是或的关系，使用`|`构成分支，`/^[+-]?\d+\.\d+$|^[+-]?\d+$|^[+-]?\.\d+$/`  
提取公共部分，写成`/^[+-]?(\d+\.\d+|\d+|\.\d+)$/`，其可视化形式为：

![](http://source.strugglexiang.xyz/1569313224.jpg)

如果要求不匹配`+.2`、`-.2`，正则写成`/^([+-]?(\d+\.\d+|\d+)|\.\d+)$/`，其可视化形式为：

![](http://source.strugglexiang.xyz/1569313497.jpg)


当然，`/^[+-]?(\d+\.\d+|\d+|\.\d+)$/`也不是完美的：
* 整数部分也会匹配01、02、01234这种形式。如何要求不匹配，需要修改整数部分的规则。
* 括号里面的内容也可以进一步简化，`/^[+-]?(\d+)?(\.)?\d+$/`，这样需要考虑到可读性和可维护性（显而易见，使用括号分支可读性和可维护性高很多）。
* 如果在验证操作之前进行了`trim`和判空操作的话，`/^[+-]?(\d+)?(\.\d+)$/`也能够用。

还记得开头说的4个需要平衡的点吗？最后的正则形式，一般都有平衡取舍问题，一般够用就行，具体就看业务需求。

# 效率
保证正则的准确性后，才需要考虑优化问题，大多数情况下是不需要优化的，除非运行特别慢。那么什么情况下正则表达式运行会慢？这就需要分析正则的运行过程了。

一般来说，正则运行分为以下步骤：

1. 编译
2. 设定匹配位置
3. 尝试匹配
4. 匹配失败，从下一位开始重新进行第3步
5. 最终结果：匹配成功或失败。

我们来看一个明显的例子，看看正则的运行过程，如下：
```js
var regex = /\d+/g;
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 0 ["123", index: 0, input: "123abc34def", groups: undefined]
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 3 ["34", index: 6, input: "123abc34def", groups: undefined] 
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 8 null
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 0 ["123", index: 0, input: "123abc34def", groups: undefined]
```
分析：

首先生成正则`var regex = /\d+/g`，引擎会对其进行编译，报错是否会出现在这个阶段。

然后运行`regex.exec("123abc34def")`开始尝试匹配，匹配需要确定从哪一位开始，一般都是字符串的开头，最初默认为0。

当使用`test`和`exec`方法，并且正则有`g`修饰符时，会从表达式的`lastIndex`开始匹配。

第一次`exec`是从第0位开始尝试匹配，并成功匹配到3个数字`123`，此时结束的下标是`2`，因此下次匹配的起始位置为3。

第二次`exec`从下标3开始尝试匹配，但是下标3的字符是`a`，不是数字，这个时候不会报匹配失败，而是往后移一位，继续尝试匹配。直到匹配到数字`34`，此时下标为7，因此下次匹配的位置是8。

第三次`exec`从下标8的位置也就是第9位字符开始匹配，直到尝试到最后一个位置，也没有匹配成功。此时返回`null`，并同时设置`lastIndex`为0，即下次匹配就从头开始。

第四次`exec`又从0开始匹配。


从上述示例可以看出，匹配会出现效率问题，主要体现在第3步和第4步。因此，主要的优化手段也就是针对第3步和第4步。即减少尝试匹配的次数。


## 使用具体字符组替代通配符
第3步是尝试匹配，最大的问题就是回溯。

例如用`/".*"/`去匹配字符串`123"abc"456`中的`"abc"`（粉色表示.*匹配的内容），匹配过程如下：

![](http://source.strugglexiang.xyz/reg_6_1.png)

可见，回溯导致匹配次数增多。

如果用`/".*?"/`，可以减少回溯次数。匹配过程如下（粉色表示.*匹配的内容）：

![](http://source.strugglexiang.xyz/reg_6_2.png)

由于回溯法原理，引擎需要保存多种可能中未尝试过的状态，方便后续回溯使用。这注定会占用一些内存。

此时我们可以使用具体的字符组代替通配符`.`，消除不必要匹配的字符，减少匹配次数，使用正则`/"[^"]*"/`即可。

## 使用非捕型分组
括号的作用之一就是捕获分组和分支的数据，方面后面引用，这就需要内存来保存括号记忆的内容。

当我们不需要引用分组和反向引用时，可以使用非捕获括号来替代捕获括号，降低内存消耗。

例如`/^[+-]?(\d+\.\d+|\d+|\.\d+)$/`就可以修改成`/^[+-]?(?:\d+\.\d+|\d+|\.\d+)$/`


## 独立出确定字符
比如`/a+/`可以改为`/aa*/`，因为后者比前者多确定了字符`a`，在第4步中，加速判断是否匹配失败，加速目标字符串移位的速度。

> 对于老姚的这个示例，说实话本人不是很理解。因为在我看来，`a+`和`a`都是确定的字符。

## 提取分支公共部分
比如`/^abc|^def/`可以修改为`/^(?:abc|def)/`

又比如`/this|that/`可以修改为`/th(?:is|at)/`

这样做，可以减少匹配过程中可消除的重复。

## 减少分支数量
比如`/red|read/`可以修改为`rea?d`。此时分支和量词产生的回溯成本是不一样的。但是这样修改，会降低可读性。


# 总结
本章涉及的内容并不多，一般情况下，能够针对问题，写出满足需求的正则就可以了。至于优化，大多数情况是不需要的，我们了解了一下优化原理和常见的优化手段。至于准确性，本章关心的是常用的解决思路：针对每种情形，写出它们的正则表达式，再用分支把他们合并在一起，然后提起分支的公共部分，就能得到准确的正则。
