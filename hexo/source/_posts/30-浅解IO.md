---
title: 浅解IO
date: 2020-03-18 14:19:02
categories: 理解计算机
tags:
---


# 引子
最近在看狼叔写的《狼书》来学习Node.js。书中说到：非阻塞I/O是Node.js的特性，我对此不是很理解。非阻塞I/O是什么？这个概念好像在很多地方都有提及，于是有了这篇探索记录。

<!-- more -->

# 一次网络I/O
计算机的组成其实非常简单，处理器、存储器再加上输入、输出设备就能构成一台计算机。大至超级计算机，小至我们日常使用的手机，都是这样的模型。计算的本质就是处理器读取输入设备的数据处理后再输出。可以说，计算机的任务就是计算和I/O。

在网络发明之前，计算机从存储设备中读取数据，进程通过内存通道进行通信。互联网发明之后，越来越多的计算机通过互联网连接，将数据传递到世界各地。计算机之间的通信，本质上就是计算机进程之间相互通信。

网络通信，一般的模式是客户端（client）发起网络请求，服务端（server）接收请求再响应。例如我们平常浏览网页，在浏览器输入网址发起请求，请求服务器上的一个html文件，服务器接收到请求后，会先读取磁盘的html文件，再将html文件返回给客户端。这样一个过程，涉及到了网络I/O和磁盘文件I/O。它的大致流程如下。

![io](https://source.strugglexiang.xyz/io1.jpg)

上图只展示了server端的响应过程：
1. server发起read系统调用，内核将磁盘文件的数据copy到内核缓冲区。（此次copy没有cpu的参与）
2. 内核再将缓冲区的数据copy到应用程序的进程缓冲区，此时应用程序可以对数据进行处理。（有cpu参与）
3. 应用进程发起send系统调用将数据发送到socket缓冲区。每个socket文件都在内核中维护了发送/接受缓冲区。
4. 最后再将socekt缓冲区数据copy到NIC网卡。server的NIC网卡通过网络协议将数据发送到客户端的网卡中。
5. 客户端的应用程序接受数据中，也会发送一个Recv系统调用，然后内核会从NIC网卡中读取数据到内核缓冲区，再将缓冲区数据copy到client应用进程的缓冲区。

整个过程中，文件数据主要在硬件、内核、应用三个层次上流动。流动的过程中，将数据从一个层次copy到另一个层次，称之为**I/O操作**。

> DMA: Direct Memory Access，直接访问内存方式，即现在的计算机硬件可以独立的读写系统内存（内核空间 kernel space），而不需要cpu的完全介入。也就说，数据从硬盘或者NIC网卡copy到内核中，不要计算机cpu的参与，而是由设备上的芯片参与。对于内核来说，此时cpu可以去做其他事情。

# 一次I/O过程
什么是I/O呢？程序的运行，会占用内存，而内存又分为用户空间和内核空间。**所谓I/O，就是将硬件（磁盘、NIC网卡）的数据读取到应用程序的内存中**。通常，应用程序很少能和硬件直接交互，需要操作系统作为二者（应用程序、硬件）的桥梁。操作系统有自己的内核buf，先将硬件的数据读取到内核buf中，再将内核buf的数据发送到应用程序的内存。

以读I/O为例:

![io](https://source.strugglexiang.xyz/io2.jpg)

1. 应用程序首先发送read系统调用。
2. 系统内核接受应用的请求，如果内核中有数据，就将数据copy到应用buf中，调用结束；如果没有数据，内核就会和I/O模块发送请求，I/O模块和硬件交互。
3. 当NIC网卡接受到网络数据后，NIC会利用DMA技术将数据copy到内核buf。
4. 最后，cpu将内核buf的数据发送到我们的应用程序的buf。

一般的网络I/O分为两个阶段： 
1. 等待数据阶段：通过网络协议将数据发送到NIC网卡，网卡再通过DMA技术copy到内核buf。
2. 数据拷贝阶段：将内核buf的数据copy到进程buf中。


# I/O模型
《UNIX网络编程》中提到了5中基本的网络I/O模型:
1. 阻塞I/O（blocking）
2. 非阻塞I/O（nonblocking）
3. 多路复用I/O（multiplexing）
4. 信号驱动I/O（SIGIO）
5. 异步I/O（asynchronous）

这5种I/O模型的具体细节就不介绍了，因为我本人也有很多不懂的地方，这里只阐述I/O的阻塞和非阻塞、I/O的同步和异步。

经过前面的介绍，我们知道，I/O有两个阶段，一个等待数据阶段，一个是数据copy阶段。

进程发起I/O请求

第一阶段：数据等待
* 进程挂起：I/O阻塞
* 进程运行：I/O非阻塞

第二阶段：数据copy，需要cpu的参与
* 进程挂起：I/O同步，内核拷贝数据占据cpu
* 进程运行：I/O异步，进程可能和内核竞争CPU


# 总结
1. 什么是I/O：数据在应用内存、内核缓存、硬件三个层次间的流动过程我们称之为I/O。
2. I/O分为两个阶段：等待数据阶段和数据copy阶段。
3. 等待数据阶段，进程是否运行决定了I/O是否阻塞；数据copy阶段，进程是否运行决定了I/O是否同步。


# 参考
[简明网络I/O](https://www.jianshu.com/p/e62f0ef9629d)

[程序员应该这样理解IO](https://www.jianshu.com/p/fa7bdc4f3de7)

[聊聊Linux 五种IO模型](https://www.jianshu.com/p/486b0965c296)

