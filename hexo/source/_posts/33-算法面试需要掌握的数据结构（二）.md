---
title: 算法面试需要掌握的数据结构（二）
date: 2020-05-19 10:51:39
categories:
    - JavaScript
    - 数据结构和算法
tags:
---


# 线性数据结构
我们知道，数组中的数据呈线性一个接一个排列，我们称其数据结构是线性的。在所有的线性数据结构中，最常见的栈、队列以及链表。本篇就记录有关栈、队列、链表的基础知识。

<!-- more -->

# 栈和队列
在`JS`中，栈和队列的实现一般都依托于数组来实现。它们可以看作是一种特殊的数组。它们和数组的区别在于**对增删操作有特殊的限制**。

普通的数组结构，它的增删没有任何限制，普通数组可以在任意位置增删自己的元素。

栈只能增删末尾位置的元素。

队列只能增删头部位置的元素。


## 栈（stack）
栈是一种先进后出的数据结构，它只能增删末尾位置的元素。

栈可以看作只能使用`push`和`pop`方法的数组(push为增，pop为删)。

为了快速理解和记忆栈，我们可以把它理解为小卖部卖冰淇淋的冰箱，在放入冰淇淋时，越先放入的冰淇淋越接近底部位置。在拿出时，会先拿顶部位置的冰淇淋，再拿位于底部位置的。也就是说，先放入的冰淇淋反而后拿出。

```js
// 栈的增删
let stack = []
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
while(stack.length) {
    // 栈顶元素
    const top = stack[stack.length - 1]
    console.log('当前拿出的元素是', top)
    stack.pop()
}
```
栈的增删的问题，一边比较关键的点是找到栈顶元素。


## 队列（queue）
队列是一种先进先出的数据结构。它可以看作只能使用`push`和`shift`方法的数组（push为增，shift为删）。

方便记忆与理解，可以将队列看作去麦当劳买餐排队的队伍。排在前面的人先付款买单，因此先脱离队伍。也就是说先排队的人先出去。

```js
const queue = []
queue.push(1)
queue.push(2)
queue.push(3)
queue.push(4)

while(queue.length) {
    // 队头元素
    const top = queue[0]
    console.log('当前出队的元素', top)
    queue.shift()
}
```
在处理有关队列的问题时，一般关键点是找到队头元素

# 链表
链表也是一种线性数据结构，它和数组的区别主要在于**元素在内存中的存储规律不同**。

数组在内存中的表现是**一段连续的内存空间**，其中元素紧紧相连，一个接一个，只要知道第一个元素在内存中的位置，就能根据当前元素的索引值推算出当前元素在内存中的位置。因此对于数组来说，每一个元素都可以直接通过下标直接定位。

链表和数组不同，它允许内部元素散落在内存的不同位置，它的数据在内存中的可以是离散的。正是因为数据离散，当前元素除了存储元素的值，还需存储下一个元素的索引。

链表中的每个元素称为节点，每个节点的结构都包含两部分：数据域与指针域。

在js中，链表是以对象嵌套的形式存在
```js
{
    val: 1,
    next: {
        val: 2,
        next: {
            val: 3,
            next: 4
        }
    }
}
```
图解如下：
![](https://source.strugglexiang.xyz/20_5_14_4.jpg)

想要访问链表中的节点，我们必须从起点结点开始，逐个访问`next`，直到找到我们的目标节点。为了确保起点位置是可抵达的，有时我们会创建一个head节点指向链表的开始位置。
![](https://source.strugglexiang.xyz/20_5_14_3.jpg)


## 链表节点的创建
创建链表节点，需要创建一个构造函数
```js
function chainNode(val) {
    this.value = val
    this.next = null
}
```

节点创建后，将当前节点的`next`值指向下一个节点就构成一个链表
```js
const node1 = new chainNode(1)
const node2 = new chainNode(2)
node1.next = node2
```

## 链表元素的添加
在末尾添加元素是很简单的，只需将最后一个节点的next指向新的节点就行。

重要的是如何在任意两个节点间添加一个新的节点。这里的关键是**找到前驱节点和目标节点并调整它们next的指向**。
1. 找到前驱节点和目标节点。
2. 目标节点的next指向前驱节点的next
3. 前驱节点的next指向目标节点
```js
// 创建一个链表
function chainNode(value) {
    this.value = value
    this.next = null
}

const node1 = new chainNode(1)
const node2 = new chainNode(2)
node1.next = node2

// 在node1和node2之间添加node3
const node3 = new chainNode(3)
node3.next = node1.next
node1.next = node3
```

## 链表元素的删除
删除链表元素的关键是找到要删除元素的前驱，前驱的next指向被删除节点的next就行。
```js
// 创建链表
function chainNode(value) {
    this.value = value
    this.next = null
}

const node1 = new chainNode(1)
const node2 = new chainNode(2)
const node3 = new chainNode(3)

node1.next = node2
node2.next = node3

// 删除node2
node1.next = node2.next
```
此时，node2没有被任何地方引用，js的垃圾回收机制会自动回收node2。

## 链表和数组辨析
### JS中的数组
在大部分编程语言中，数组是一段连续的内存空间，但是在`JS`中却不一定。

当数组中的元素都是基础类型时，内存中数组的元素地址是相连的。
如：
```js
// 真正的数组
let arr = [1, 2, 3]
```

但是当数组中元素同时存在引用类型和基础类型时，它对应的就是一段非连续的地址，它在内存空间中就不据有数组的特征。
如：
```js
let arr = [1, 2, { ni: 'hao' }]
```

总之，记住一点: JS中的数组未必是真正的数组。

### 链表高效的删除操作
数组是一段连续的内存空间。当我们在数组的任意位置删除一个元素时，该位置后面的元素都要向前移动一个位置；当我们在任意位置添加一个元素时，那么该位置后面的所有元素都要向后移动一个位置。

我们假设数组的长度是n，因增加或删除操作而导致需要移动的元素数量，就会随着n的增大而增大，呈现一个线性关系。因此数组增加或删除操作的时间复杂度为O(n)。

相比于数组，不论链表的节点数n有多大，我们只需明确要插入或删除的位置，改变前驱或后置的指针指向就可以达到目的，不需要移动元素的位置。因此链表增删元素的时间复杂度是常数级别的，表达为O(1)。

### 链表麻烦的访问操作
数组元素的访问只需通过下标就能快速访问。但是链表不一样，链表的访问需要遍历整个链表来找到目标节点。

假设需要访问链表的第10个节点
```js
const index = 10
let node = head // head节点
for(let i = 0; i < index; i++) {
    node = node.next
}
```
随着链表长度的增加，搜所范围就会越来越大，访问链表元素的时间成本就会随之提高，呈一个线性关系，时间复杂度为O(n)

在数组中，可以直接通过索引值访问目标元素，只需要一步操作，这个访问操作的时间复杂度为常数级别O(1)

